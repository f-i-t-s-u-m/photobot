{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Project/Fiba/photobot/database.ts"],"sourcesContent":["import { createClient, Client } from \"@libsql/client\";\r\nimport dotenv from \"dotenv\";\r\ndotenv.config();\r\n\r\n// Type definitions\r\ninterface User {\r\n  user_id: string;\r\n  watermark_file_id: string;\r\n  watermark_position: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\ninterface DatabaseRow {\r\n  [key: string]: any;\r\n}\r\n\r\n// Initialize Turso client\r\nconst client: Client = createClient({\r\n  url: process.env.TURSO_DATABASE_URL!,\r\n  authToken: process.env.TURSO_AUTH_TOKEN!,\r\n});\r\n\r\n// Initialize database with required tables\r\nasync function initializeDatabase(): Promise<void> {\r\n  try {\r\n    await client.execute(`\r\n      CREATE TABLE IF NOT EXISTS users (\r\n        user_id TEXT PRIMARY KEY,\r\n        watermark_file_id TEXT,\r\n        watermark_position TEXT DEFAULT 'bottom',\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )\r\n    `);\r\n    console.log(\"Database initialized successfully\");\r\n  } catch (error) {\r\n    console.error(\"Error initializing database:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Get user from database\r\nasync function getUser(userId: string): Promise<User | null> {\r\n  try {\r\n    const result = await client.execute({\r\n      sql: \"SELECT * FROM users WHERE user_id = ?\",\r\n      args: [userId],\r\n    });\r\n    const row = result.rows[0];\r\n    if (!row) return null;\r\n    return {\r\n      user_id: row.user_id as string,\r\n      watermark_file_id: row.watermark_file_id as string,\r\n      watermark_position: row.watermark_position as string,\r\n      created_at: row.created_at as string,\r\n      updated_at: row.updated_at as string,\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error getting user:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Create or update user watermark\r\nasync function setUserWatermark(\r\n  userId: string,\r\n  watermarkFileId: string,\r\n  position: string = \"bottom\"\r\n): Promise<void> {\r\n  try {\r\n    await client.execute({\r\n      sql: `\r\n        INSERT INTO users (user_id, watermark_file_id, watermark_position, updated_at)\r\n        VALUES (?, ?, ?, CURRENT_TIMESTAMP)\r\n        ON CONFLICT(user_id) DO UPDATE SET\r\n          watermark_file_id = excluded.watermark_file_id,\r\n          watermark_position = excluded.watermark_position,\r\n          updated_at = CURRENT_TIMESTAMP\r\n      `,\r\n      args: [userId, watermarkFileId, position],\r\n    });\r\n    console.log(`Watermark set for user ${userId}`);\r\n  } catch (error) {\r\n    console.error(\"Error setting user watermark:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Update watermark position\r\nasync function updateWatermarkPosition(\r\n  userId: string,\r\n  position: string\r\n): Promise<void> {\r\n  try {\r\n    await client.execute({\r\n      sql: \"UPDATE users SET watermark_position = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?\",\r\n      args: [position, userId],\r\n    });\r\n    console.log(`Position updated for user ${userId} to ${position}`);\r\n  } catch (error) {\r\n    console.error(\"Error updating watermark position:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Check if user exists and has watermark\r\nasync function hasWatermark(userId: string): Promise<boolean> {\r\n  try {\r\n    const user = await getUser(userId);\r\n    return user !== null && !!user.watermark_file_id;\r\n  } catch (error) {\r\n    console.error(\"Error checking watermark:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport {\r\n  initializeDatabase,\r\n  getUser,\r\n  setUserWatermark,\r\n  updateWatermarkPosition,\r\n  hasWatermark,\r\n};\r\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;;;;;AACA,uIAAA,CAAA,UAAM,CAAC,MAAM;AAeb,0BAA0B;AAC1B,MAAM,SAAiB,CAAA,GAAA,oIAAA,CAAA,eAAY,AAAD,EAAE;IAClC,KAAK,QAAQ,GAAG,CAAC,kBAAkB;IACnC,WAAW,QAAQ,GAAG,CAAC,gBAAgB;AACzC;AAEA,2CAA2C;AAC3C,eAAe;IACb,IAAI;QACF,MAAM,OAAO,OAAO,CAAC,CAAC;;;;;;;;IAQtB,CAAC;QACD,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,MAAM;IACR;AACF;AAEA,yBAAyB;AACzB,eAAe,QAAQ,MAAc;IACnC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,OAAO,CAAC;YAClC,KAAK;YACL,MAAM;gBAAC;aAAO;QAChB;QACA,MAAM,MAAM,OAAO,IAAI,CAAC,EAAE;QAC1B,IAAI,CAAC,KAAK,OAAO;QACjB,OAAO;YACL,SAAS,IAAI,OAAO;YACpB,mBAAmB,IAAI,iBAAiB;YACxC,oBAAoB,IAAI,kBAAkB;YAC1C,YAAY,IAAI,UAAU;YAC1B,YAAY,IAAI,UAAU;QAC5B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,MAAM;IACR;AACF;AAEA,kCAAkC;AAClC,eAAe,iBACb,MAAc,EACd,eAAuB,EACvB,WAAmB,QAAQ;IAE3B,IAAI;QACF,MAAM,OAAO,OAAO,CAAC;YACnB,KAAK,CAAC;;;;;;;MAON,CAAC;YACD,MAAM;gBAAC;gBAAQ;gBAAiB;aAAS;QAC3C;QACA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,QAAQ;IAChD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEA,4BAA4B;AAC5B,eAAe,wBACb,MAAc,EACd,QAAgB;IAEhB,IAAI;QACF,MAAM,OAAO,OAAO,CAAC;YACnB,KAAK;YACL,MAAM;gBAAC;gBAAU;aAAO;QAC1B;QACA,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,OAAO,IAAI,EAAE,UAAU;IAClE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,MAAM;IACR;AACF;AAEA,yCAAyC;AACzC,eAAe,aAAa,MAAc;IACxC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ;QAC3B,OAAO,SAAS,QAAQ,CAAC,CAAC,KAAK,iBAAiB;IAClD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 342, "column": 0}, "map": {"version":3,"sources":["file:///C:/Project/Fiba/photobot/imageProcessor.ts"],"sourcesContent":["import sharp from \"sharp\";\r\nimport axios from \"axios\";\r\nimport TelegramBot from \"node-telegram-bot-api\";\r\n\r\n// Type definitions\r\ninterface WatermarkPosition {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ntype WatermarkPositionType =\r\n  | \"top-left\"\r\n  | \"top-right\"\r\n  | \"top\"\r\n  | \"center\"\r\n  | \"bottom-left\"\r\n  | \"bottom-right\"\r\n  | \"bottom\";\r\n\r\ninterface TelegramFile {\r\n  file_id: string;\r\n  file_path: string;\r\n  file_size?: number;\r\n}\r\n\r\n// Download image from Telegram file ID\r\nasync function downloadImage(\r\n  fileId: string,\r\n  bot: TelegramBot\r\n): Promise<Buffer> {\r\n  try {\r\n    const file = await bot.getFile(fileId);\r\n    if (!file.file_path) {\r\n      throw new Error(\"File path not found\");\r\n    }\r\n    const response = await axios.get(\r\n      `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`,\r\n      {\r\n        responseType: \"arraybuffer\",\r\n      }\r\n    );\r\n    return Buffer.from(response.data);\r\n  } catch (error) {\r\n    console.error(\"Error downloading image:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Calculate watermark position and size\r\nfunction calculateWatermarkPosition(\r\n  photoWidth: number,\r\n  photoHeight: number,\r\n  watermarkWidth: number,\r\n  watermarkHeight: number,\r\n  position: WatermarkPositionType\r\n): WatermarkPosition {\r\n  // Make watermark full width of the photo\r\n  const scaledWatermarkWidth = photoWidth;\r\n  const scaledWatermarkHeight = (watermarkHeight / watermarkWidth) * photoWidth;\r\n\r\n  let x: number, y: number;\r\n\r\n  switch (position) {\r\n    case \"top-left\":\r\n    case \"top-right\":\r\n    case \"top\":\r\n      x = 0;\r\n      y = 0;\r\n      break;\r\n    case \"center\":\r\n      x = 0;\r\n      y = (photoHeight - scaledWatermarkHeight) / 2;\r\n      break;\r\n    case \"bottom-left\":\r\n    case \"bottom-right\":\r\n    case \"bottom\":\r\n    default:\r\n      x = 0;\r\n      y = photoHeight - scaledWatermarkHeight;\r\n      break;\r\n  }\r\n\r\n  return {\r\n    x: Math.max(0, Math.round(x)),\r\n    y: Math.max(0, Math.round(y)),\r\n    width: Math.round(scaledWatermarkWidth),\r\n    height: Math.round(scaledWatermarkHeight),\r\n  };\r\n}\r\n\r\n// Apply watermark to image\r\nasync function applyWatermark(\r\n  photoBuffer: Buffer,\r\n  watermarkBuffer: Buffer,\r\n  position: WatermarkPositionType = \"bottom\"\r\n): Promise<Buffer> {\r\n  try {\r\n    // Get image metadata\r\n    const photoMetadata = await sharp(photoBuffer).metadata();\r\n    const watermarkMetadata = await sharp(watermarkBuffer).metadata();\r\n\r\n    if (\r\n      !photoMetadata.width ||\r\n      !photoMetadata.height ||\r\n      !watermarkMetadata.width ||\r\n      !watermarkMetadata.height\r\n    ) {\r\n      throw new Error(\"Invalid image metadata\");\r\n    }\r\n\r\n    // Calculate watermark position and size\r\n    const { x, y, width, height } = calculateWatermarkPosition(\r\n      photoMetadata.width,\r\n      photoMetadata.height,\r\n      watermarkMetadata.width,\r\n      watermarkMetadata.height,\r\n      position\r\n    );\r\n\r\n    // Resize watermark\r\n    const resizedWatermark = await sharp(watermarkBuffer)\r\n      .resize(width, height, {\r\n        fit: \"contain\",\r\n        background: { r: 0, g: 0, b: 0, alpha: 0 },\r\n      })\r\n      .png()\r\n      .toBuffer();\r\n\r\n    // Create composite image\r\n    const watermarkedImage = await sharp(photoBuffer)\r\n      .composite([\r\n        {\r\n          input: resizedWatermark,\r\n          top: y,\r\n          left: x,\r\n        },\r\n      ])\r\n      .jpeg({ quality: 90 })\r\n      .toBuffer();\r\n\r\n    return watermarkedImage;\r\n  } catch (error) {\r\n    console.error(\"Error applying watermark:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Process image with watermark\r\nasync function processImage(\r\n  photoFileId: string,\r\n  watermarkFileId: string,\r\n  position: WatermarkPositionType,\r\n  bot: TelegramBot\r\n): Promise<Buffer> {\r\n  try {\r\n    // Download both images\r\n    const [photoBuffer, watermarkBuffer] = await Promise.all([\r\n      downloadImage(photoFileId, bot),\r\n      downloadImage(watermarkFileId, bot),\r\n    ]);\r\n\r\n    // Apply watermark\r\n    const watermarkedBuffer = await applyWatermark(\r\n      photoBuffer,\r\n      watermarkBuffer,\r\n      position\r\n    );\r\n\r\n    return watermarkedBuffer;\r\n  } catch (error) {\r\n    console.error(\"Error processing image:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport {\r\n  downloadImage,\r\n  applyWatermark,\r\n  processImage,\r\n  calculateWatermarkPosition,\r\n  type WatermarkPositionType,\r\n  type WatermarkPosition,\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Project/Fiba/photobot/bot.ts"],"sourcesContent":["import TelegramBot from \"node-telegram-bot-api\";\r\nimport {\r\n  initializeDatabase,\r\n  getUser,\r\n  setUserWatermark,\r\n  updateWatermarkPosition,\r\n  hasWatermark,\r\n} from \"./database\";\r\nimport { processImage, type WatermarkPositionType } from \"./imageProcessor\";\r\nimport axios from \"axios\";\r\n\r\n// Type definitions\r\ninterface TelegramMessage {\r\n  message_id: number;\r\n  from: {\r\n    id: number;\r\n    username?: string;\r\n    first_name?: string;\r\n  };\r\n  chat: {\r\n    id: number;\r\n    type: string;\r\n  };\r\n  text?: string;\r\n  photo?: Array<{\r\n    file_id: string;\r\n    file_size: number;\r\n    width: number;\r\n    height: number;\r\n  }>;\r\n}\r\n\r\ninterface TelegramCallbackQuery {\r\n  id: string;\r\n  from: {\r\n    id: number;\r\n    username?: string;\r\n    first_name?: string;\r\n  };\r\n  message: {\r\n    message_id: number;\r\n    chat: {\r\n      id: number;\r\n    };\r\n  };\r\n  data: string;\r\n}\r\n\r\ninterface TelegramWebhookBody {\r\n  message?: TelegramMessage;\r\n  callback_query?: TelegramCallbackQuery;\r\n}\r\n\r\ninterface User {\r\n  user_id: string;\r\n  watermark_file_id: string;\r\n  watermark_position: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\ntype UserState =\r\n  | \"waiting_for_watermark\"\r\n  | `customizing_${string}`\r\n  | `changing_watermark_${string}`;\r\n\r\n// Initialize bot\r\nconst bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN!, {\r\n  polling: false,\r\n});\r\n\r\n// Store user states for watermark upload\r\nconst userStates = new Map<number, UserState>();\r\n\r\n// Store photo file IDs for callback handling\r\nconst photoFileIds = new Map<string, string>();\r\nlet photoCounter = 0;\r\n\r\n// Position options for watermark\r\nconst POSITION_OPTIONS: string[][] = [\r\n  [\"top-left\", \"top-right\"],\r\n  [\"center\"],\r\n  [\"bottom-left\", \"bottom-right\"],\r\n  [\"bottom\"],\r\n];\r\n\r\n// Set webhook using Telegram API directly\r\nasync function setWebhook(url: string): Promise<any> {\r\n  try {\r\n    const response = await axios.post(\r\n      `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/setWebhook`,\r\n      {\r\n        url: `${url}/api/webhook`,\r\n      }\r\n    );\r\n\r\n    console.log(response.data);\r\n\r\n    const result = response.data;\r\n    if (!result.ok) {\r\n      throw new Error(`Failed to set webhook: ${result.description}`);\r\n    }\r\n    return result;\r\n  } catch (error) {\r\n    console.error(\"Error setting webhook:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Initialize bot handlers\r\nasync function initializeBot(): Promise<void> {\r\n  try {\r\n    console.log(\"Initializing bot\");\r\n    // Initialize database\r\n    await initializeDatabase();\r\n\r\n    // Set webhook for serverless deployment\r\n    if (process.env.WEBHOOK_URL) {\r\n      console.log(\"Setting webhook to\", process.env.WEBHOOK_URL);\r\n      await setWebhook(process.env.WEBHOOK_URL);\r\n      console.log(\"Webhook set successfully\");\r\n    }\r\n\r\n    console.log(\"Bot initialized successfully\");\r\n  } catch (error) {\r\n    console.error(\"Error initializing bot:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Handle /start command\r\nasync function handleStart(msg: TelegramMessage): Promise<void> {\r\n  const userId = msg.from.id;\r\n  const chatId = msg.chat.id;\r\n\r\n  try {\r\n    const hasUserWatermark = await hasWatermark(userId.toString());\r\n\r\n    if (hasUserWatermark) {\r\n      const user = await getUser(userId.toString());\r\n      if (!user) {\r\n        const message = `Welcome to the Watermark Bot! 🖼️\\n\\nI'll help you add watermarks to your photos.\\n\\nTo get started, please send me an image that you'd like to use as your watermark (preferably a PNG with transparent background).`;\r\n        await bot.sendMessage(chatId, message);\r\n        return;\r\n      }\r\n      const message = `Welcome back! 🎉\\n\\nYour watermark is set to position: *${user.watermark_position}*\\n\\nSend me a photo to add your watermark, or send a new image to update your watermark.`;\r\n\r\n      await bot.sendMessage(chatId, message, { parse_mode: \"Markdown\" });\r\n    } else {\r\n      const message = `Welcome to the Watermark Bot! 🖼️\\n\\nI'll help you add watermarks to your photos.\\n\\nTo get started, please send me an image that you'd like to use as your watermark (preferably a PNG with transparent background).`;\r\n\r\n      userStates.set(userId, \"waiting_for_watermark\");\r\n      await bot.sendMessage(chatId, message);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error handling start command:\", error);\r\n    await bot.sendMessage(\r\n      chatId,\r\n      \"Sorry, something went wrong. Please try again.\"\r\n    );\r\n  }\r\n}\r\n\r\n// Handle photo messages\r\nasync function handlePhoto(msg: TelegramMessage): Promise<void> {\r\n  const userId = msg.from.id;\r\n  const chatId = msg.chat.id;\r\n  const photo = msg.photo![msg.photo!.length - 1]; // Get the largest photo\r\n  const fileId = photo.file_id;\r\n\r\n  try {\r\n    const userState = userStates.get(userId);\r\n\r\n    // If user is waiting to upload watermark\r\n    if (userState === \"waiting_for_watermark\") {\r\n      await setUserWatermark(userId.toString(), fileId);\r\n      userStates.delete(userId);\r\n\r\n      const message = `Perfect! ✅ Your watermark has been set.\\n\\nNow send me any photo and I'll add your watermark to it!`;\r\n      await bot.sendMessage(chatId, message);\r\n      return;\r\n    }\r\n\r\n    // If user is changing watermark for a specific photo\r\n    if (userState && userState.startsWith(\"changing_watermark_\")) {\r\n      const photoId = userState.split(\"_\")[2];\r\n      const photoFileId = photoFileIds.get(photoId);\r\n\r\n      if (!photoFileId) {\r\n        await bot.sendMessage(\r\n          chatId,\r\n          \"Original photo not found. Please try processing a new photo.\"\r\n        );\r\n        userStates.delete(userId);\r\n        return;\r\n      }\r\n\r\n      // Update user's watermark\r\n      await setUserWatermark(userId.toString(), fileId);\r\n      userStates.delete(userId);\r\n\r\n      // Get user's updated data\r\n      const user = await getUser(userId.toString());\r\n      if (!user) {\r\n        await bot.sendMessage(\r\n          chatId,\r\n          \"User data not found. Please try /start again.\"\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Process the original photo with new watermark\r\n      const watermarkedBuffer = await processImage(\r\n        photoFileId,\r\n        user.watermark_file_id,\r\n        user.watermark_position as WatermarkPositionType,\r\n        bot\r\n      );\r\n\r\n      // Create keyboard with both buttons\r\n      const keyboard = {\r\n        inline_keyboard: [\r\n          [\r\n            {\r\n              text: \"🎨 Customize Position\",\r\n              callback_data: `customize_${photoId}`,\r\n            },\r\n            {\r\n              text: \"🔄 Change Watermark\",\r\n              callback_data: `change_watermark_${photoId}`,\r\n            },\r\n          ],\r\n        ],\r\n      };\r\n\r\n      // Send updated photo\r\n      await bot.sendPhoto(chatId, watermarkedBuffer, {\r\n        caption: `Updated! New watermark applied. Position: ${user.watermark_position}`,\r\n        reply_markup: keyboard,\r\n      });\r\n\r\n      await bot.sendMessage(chatId, \"✅ Watermark updated successfully!\");\r\n      return;\r\n    }\r\n\r\n    // Check if user has watermark\r\n    const hasUserWatermark = await hasWatermark(userId.toString());\r\n\r\n    if (!hasUserWatermark) {\r\n      const message = `You don't have a watermark set yet. Please send me an image to use as your watermark first.`;\r\n      userStates.set(userId, \"waiting_for_watermark\");\r\n      await bot.sendMessage(chatId, message);\r\n      return;\r\n    }\r\n\r\n    // Process the photo with watermark\r\n    const user = await getUser(userId.toString());\r\n    if (!user) {\r\n      await bot.sendMessage(\r\n        chatId,\r\n        \"User data not found. Please try /start again.\"\r\n      );\r\n      return;\r\n    }\r\n    const watermarkedBuffer = await processImage(\r\n      fileId,\r\n      user.watermark_file_id,\r\n      user.watermark_position as WatermarkPositionType,\r\n      bot\r\n    );\r\n\r\n    // Create a short identifier for the photo\r\n    const photoId = `p${++photoCounter}`;\r\n    photoFileIds.set(photoId, fileId);\r\n\r\n    // Clean up old photo IDs to prevent memory leaks (keep only last 100)\r\n    if (photoFileIds.size > 100) {\r\n      const keysToDelete = Array.from(photoFileIds.keys()).slice(\r\n        0,\r\n        photoFileIds.size - 100\r\n      );\r\n      keysToDelete.forEach((key) => photoFileIds.delete(key));\r\n    }\r\n\r\n    // Create inline keyboard for position customization\r\n    const keyboard = {\r\n      inline_keyboard: [\r\n        [\r\n          {\r\n            text: \"🎨 Customize Position\",\r\n            callback_data: `customize_${photoId}`,\r\n          },\r\n          {\r\n            text: \"🔄 Change Watermark\",\r\n            callback_data: `change_watermark_${photoId}`,\r\n          },\r\n        ],\r\n      ],\r\n    };\r\n\r\n    // Send watermarked photo\r\n    await bot.sendPhoto(chatId, watermarkedBuffer, {\r\n      caption: `Here's your photo with watermark! Position: ${user.watermark_position}`,\r\n      reply_markup: keyboard,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error handling photo:\", error);\r\n    await bot.sendMessage(\r\n      chatId,\r\n      \"Sorry, there was an error processing your photo. Please try again.\"\r\n    );\r\n  }\r\n}\r\n\r\n// Handle callback queries (inline buttons)\r\nasync function handleCallbackQuery(\r\n  query: TelegramCallbackQuery\r\n): Promise<void> {\r\n  const userId = query.from.id;\r\n  const chatId = query.message.chat.id;\r\n  const data = query.data;\r\n\r\n  try {\r\n    if (data.startsWith(\"customize_\")) {\r\n      const photoId = data.split(\"_\")[1];\r\n      const photoFileId = photoFileIds.get(photoId);\r\n\r\n      if (!photoFileId) {\r\n        await bot.answerCallbackQuery(query.id, {\r\n          text: \"Photo not found. Please try again.\",\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Store the photo file ID for later use\r\n      userStates.set(userId, `customizing_${photoId}`);\r\n\r\n      const keyboard = {\r\n        inline_keyboard: POSITION_OPTIONS.map((row) =>\r\n          row.map((position) => ({\r\n            text: position.replace(\"-\", \" \").toUpperCase(),\r\n            callback_data: `position_${position}_${photoId}`,\r\n          }))\r\n        ),\r\n      };\r\n\r\n      await bot.editMessageReplyMarkup(keyboard, {\r\n        chat_id: chatId,\r\n        message_id: query.message.message_id,\r\n      });\r\n\r\n      try {\r\n        await bot.answerCallbackQuery(query.id, {\r\n          text: \"Choose watermark position:\",\r\n        });\r\n      } catch (error) {\r\n        console.log(\r\n          \"Callback query already answered or timed out, continuing...\"\r\n        );\r\n      }\r\n    } else if (data.startsWith(\"position_\")) {\r\n      const [, position, photoId] = data.split(\"_\");\r\n      const photoFileId = photoFileIds.get(photoId);\r\n\r\n      if (!photoFileId) {\r\n        try {\r\n          await bot.answerCallbackQuery(query.id, {\r\n            text: \"Photo not found. Please try again.\",\r\n          });\r\n        } catch (error) {\r\n          console.log(\r\n            \"Callback query already answered or timed out, continuing...\"\r\n          );\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Update user's watermark position\r\n      await updateWatermarkPosition(userId.toString(), position);\r\n\r\n      // Get user's watermark\r\n      const user = await getUser(userId.toString());\r\n      if (!user) {\r\n        await bot.answerCallbackQuery(query.id, {\r\n          text: \"User data not found. Please try /start again.\",\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Process photo with new position\r\n      const watermarkedBuffer = await processImage(\r\n        photoFileId,\r\n        user.watermark_file_id,\r\n        position as WatermarkPositionType,\r\n        bot\r\n      );\r\n\r\n      // Create new keyboard\r\n      const keyboard = {\r\n        inline_keyboard: [\r\n          [\r\n            {\r\n              text: \"🎨 Customize Position\",\r\n              callback_data: `customize_${photoId}`,\r\n            },\r\n            {\r\n              text: \"🔄 Change Watermark\",\r\n              callback_data: `change_watermark_${photoId}`,\r\n            },\r\n          ],\r\n        ],\r\n      };\r\n\r\n      // Send updated photo\r\n      await bot.sendPhoto(chatId, watermarkedBuffer, {\r\n        caption: `Updated! Watermark position: ${position}`,\r\n        reply_markup: keyboard,\r\n      });\r\n\r\n      // Delete the original message\r\n      await bot.deleteMessage(chatId, query.message.message_id);\r\n\r\n      userStates.delete(userId);\r\n      await bot.answerCallbackQuery(query.id, { text: \"Position updated!\" });\r\n    } else if (data.startsWith(\"change_watermark_\")) {\r\n      const photoId = data.split(\"_\")[2];\r\n      const photoFileId = photoFileIds.get(photoId);\r\n\r\n      if (!photoFileId) {\r\n        await bot.answerCallbackQuery(query.id, {\r\n          text: \"Photo not found. Please try again.\",\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Store the photo file ID for later use and set state to wait for new watermark\r\n      userStates.set(userId, `changing_watermark_${photoId}`);\r\n\r\n      await bot.answerCallbackQuery(query.id, {\r\n        text: \"Please send me a new watermark image.\",\r\n      });\r\n\r\n      await bot.sendMessage(\r\n        chatId,\r\n        \"Please send me a new image to use as your watermark (preferably a PNG with transparent background).\"\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error handling callback query:\", error);\r\n    await bot.answerCallbackQuery(query.id, {\r\n      text: \"Error occurred. Please try again.\",\r\n    });\r\n  }\r\n}\r\n\r\n// Handle text messages\r\nasync function handleText(msg: TelegramMessage): Promise<void> {\r\n  const userId = msg.from.id;\r\n  const chatId = msg.chat.id;\r\n  const text = msg.text!;\r\n\r\n  if (text === \"/start\") {\r\n    console.log(\"Starting bot\");\r\n    await handleStart(msg);\r\n  } else {\r\n    const userState = userStates.get(userId);\r\n\r\n    if (userState === \"waiting_for_watermark\") {\r\n      await bot.sendMessage(\r\n        chatId,\r\n        \"Please send me an image file to use as your watermark.\"\r\n      );\r\n    } else if (userState && userState.startsWith(\"changing_watermark_\")) {\r\n      await bot.sendMessage(\r\n        chatId,\r\n        \"Please send me an image file to use as your new watermark.\"\r\n      );\r\n    } else {\r\n      await bot.sendMessage(\r\n        chatId,\r\n        \"Send me a photo to add your watermark, or use /start to see your options.\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// Main message handler\r\nasync function handleMessage(msg: TelegramMessage): Promise<void> {\r\n  try {\r\n    if (msg.photo) {\r\n      await handlePhoto(msg);\r\n    } else if (msg.text) {\r\n      await handleText(msg);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error handling message:\", error);\r\n    try {\r\n      await bot.sendMessage(\r\n        msg.chat.id,\r\n        \"Sorry, something went wrong. Please try again.\"\r\n      );\r\n    } catch (sendError) {\r\n      console.error(\"Error sending error message:\", sendError);\r\n    }\r\n  }\r\n}\r\n\r\n// Webhook handler for serverless deployment\r\nasync function handleWebhook(\r\n  body: TelegramWebhookBody\r\n): Promise<{ status: string }> {\r\n  try {\r\n    if (body.message) {\r\n      await handleMessage(body.message);\r\n    } else if (body.callback_query) {\r\n      await handleCallbackQuery(body.callback_query);\r\n    }\r\n\r\n    return { status: \"OK\" };\r\n  } catch (error) {\r\n    console.error(\"Webhook error:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport { bot, initializeBot, handleMessage, handleWebhook };\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 841, "column": 0}, "map": {"version":3,"sources":["file:///C:/Project/Fiba/photobot/app/api/init/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { initializeBot } from \"../../../bot\";\r\n\r\nexport async function GET() {\r\n  try {\r\n    await initializeBot();\r\n    return NextResponse.json({\r\n      status: \"OK\",\r\n      message: \"Bot initialized successfully\",\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Initialization error:\", error);\r\n    return NextResponse.json(\r\n      {\r\n        error: \"Failed to initialize bot\",\r\n        details: error instanceof Error ? error.message : \"Unknown error\",\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;;;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,CAAA,GAAA,qGAAA,CAAA,gBAAa,AAAD;QAClB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,SAAS;YACT,WAAW,IAAI,OAAO,WAAW;QACnC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}