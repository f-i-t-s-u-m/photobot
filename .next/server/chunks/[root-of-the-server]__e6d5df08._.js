module.exports = {

"[project]/.next-internal/server/app/api/init/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/async_hooks [external] (async_hooks, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/@libsql/client [external] (@libsql/client, esm_import)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
const mod = await __turbopack_context__.y("@libsql/client");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/database.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "getUser": (()=>getUser),
    "hasWatermark": (()=>hasWatermark),
    "initializeDatabase": (()=>initializeDatabase),
    "setUserWatermark": (()=>setUserWatermark),
    "updateWatermarkPosition": (()=>updateWatermarkPosition)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/@libsql/client [external] (@libsql/client, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$29$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config();
// Initialize Turso client
const client = (0, __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$29$__["createClient"])({
    url: process.env.TURSO_DATABASE_URL,
    authToken: process.env.TURSO_AUTH_TOKEN
});
// Initialize database with required tables
async function initializeDatabase() {
    try {
        await client.execute(`
      CREATE TABLE IF NOT EXISTS users (
        user_id TEXT PRIMARY KEY,
        watermark_file_id TEXT,
        watermark_position TEXT DEFAULT 'bottom',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
        console.log("Database initialized successfully");
    } catch (error) {
        console.error("Error initializing database:", error);
        throw error;
    }
}
// Get user from database
async function getUser(userId) {
    try {
        const result = await client.execute({
            sql: "SELECT * FROM users WHERE user_id = ?",
            args: [
                userId
            ]
        });
        const row = result.rows[0];
        if (!row) return null;
        return {
            user_id: row.user_id,
            watermark_file_id: row.watermark_file_id,
            watermark_position: row.watermark_position,
            created_at: row.created_at,
            updated_at: row.updated_at
        };
    } catch (error) {
        console.error("Error getting user:", error);
        throw error;
    }
}
// Create or update user watermark
async function setUserWatermark(userId, watermarkFileId, position = "bottom") {
    try {
        await client.execute({
            sql: `
        INSERT INTO users (user_id, watermark_file_id, watermark_position, updated_at)
        VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        ON CONFLICT(user_id) DO UPDATE SET
          watermark_file_id = excluded.watermark_file_id,
          watermark_position = excluded.watermark_position,
          updated_at = CURRENT_TIMESTAMP
      `,
            args: [
                userId,
                watermarkFileId,
                position
            ]
        });
        console.log(`Watermark set for user ${userId}`);
    } catch (error) {
        console.error("Error setting user watermark:", error);
        throw error;
    }
}
// Update watermark position
async function updateWatermarkPosition(userId, position) {
    try {
        await client.execute({
            sql: "UPDATE users SET watermark_position = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?",
            args: [
                position,
                userId
            ]
        });
        console.log(`Position updated for user ${userId} to ${position}`);
    } catch (error) {
        console.error("Error updating watermark position:", error);
        throw error;
    }
}
// Check if user exists and has watermark
async function hasWatermark(userId) {
    try {
        const user = await getUser(userId);
        return user !== null && !!user.watermark_file_id;
    } catch (error) {
        console.error("Error checking watermark:", error);
        return false;
    }
}
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[externals]/sharp [external] (sharp, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("sharp", () => require("sharp"));

module.exports = mod;
}}),
"[project]/imageProcessor.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "applyWatermark": (()=>applyWatermark),
    "calculateWatermarkPosition": (()=>calculateWatermarkPosition),
    "downloadImage": (()=>downloadImage),
    "processImage": (()=>processImage)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/sharp [external] (sharp, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
;
// Download image from Telegram file ID
async function downloadImage(fileId, bot) {
    try {
        const file = await bot.getFile(fileId);
        if (!file.file_path) {
            throw new Error("File path not found");
        }
        const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`, {
            responseType: "arraybuffer"
        });
        return Buffer.from(response.data);
    } catch (error) {
        console.error("Error downloading image:", error);
        throw error;
    }
}
// Calculate watermark position and size
function calculateWatermarkPosition(photoWidth, photoHeight, watermarkWidth, watermarkHeight, position) {
    // Make watermark full width of the photo
    const scaledWatermarkWidth = photoWidth;
    const scaledWatermarkHeight = watermarkHeight / watermarkWidth * photoWidth;
    let x, y;
    switch(position){
        case "top-left":
        case "top-right":
        case "top":
            x = 0;
            y = 0;
            break;
        case "center":
            x = 0;
            y = (photoHeight - scaledWatermarkHeight) / 2;
            break;
        case "bottom-left":
        case "bottom-right":
        case "bottom":
        default:
            x = 0;
            y = photoHeight - scaledWatermarkHeight;
            break;
    }
    return {
        x: Math.max(0, Math.round(x)),
        y: Math.max(0, Math.round(y)),
        width: Math.round(scaledWatermarkWidth),
        height: Math.round(scaledWatermarkHeight)
    };
}
// Apply watermark to image
async function applyWatermark(photoBuffer, watermarkBuffer, position = "bottom") {
    try {
        // Get image metadata
        const photoMetadata = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(photoBuffer).metadata();
        const watermarkMetadata = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(watermarkBuffer).metadata();
        if (!photoMetadata.width || !photoMetadata.height || !watermarkMetadata.width || !watermarkMetadata.height) {
            throw new Error("Invalid image metadata");
        }
        // Calculate watermark position and size
        const { x, y, width, height } = calculateWatermarkPosition(photoMetadata.width, photoMetadata.height, watermarkMetadata.width, watermarkMetadata.height, position);
        // Resize watermark
        const resizedWatermark = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(watermarkBuffer).resize(width, height, {
            fit: "contain",
            background: {
                r: 0,
                g: 0,
                b: 0,
                alpha: 0
            }
        }).png().toBuffer();
        // Create composite image
        const watermarkedImage = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(photoBuffer).composite([
            {
                input: resizedWatermark,
                top: y,
                left: x
            }
        ]).jpeg({
            quality: 90
        }).toBuffer();
        return watermarkedImage;
    } catch (error) {
        console.error("Error applying watermark:", error);
        throw error;
    }
}
// Process image with watermark
async function processImage(photoFileId, watermarkFileId, position, bot) {
    try {
        // Download both images
        const [photoBuffer, watermarkBuffer] = await Promise.all([
            downloadImage(photoFileId, bot),
            downloadImage(watermarkFileId, bot)
        ]);
        // Apply watermark
        const watermarkedBuffer = await applyWatermark(photoBuffer, watermarkBuffer, position);
        return watermarkedBuffer;
    } catch (error) {
        console.error("Error processing image:", error);
        throw error;
    }
}
;
}}),
"[project]/bot.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "bot": (()=>bot),
    "handleMessage": (()=>handleMessage),
    "handleWebhook": (()=>handleWebhook),
    "initializeBot": (()=>initializeBot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$telegram$2d$bot$2d$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-telegram-bot-api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/database.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$imageProcessor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/imageProcessor.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
// Initialize bot
const bot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$telegram$2d$bot$2d$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](process.env.TELEGRAM_BOT_TOKEN, {
    polling: false
});
// Store user states for watermark upload
const userStates = new Map();
// Store photo file IDs for callback handling
const photoFileIds = new Map();
let photoCounter = 0;
// Position options for watermark
const POSITION_OPTIONS = [
    [
        "top-left",
        "top-right"
    ],
    [
        "center"
    ],
    [
        "bottom-left",
        "bottom-right"
    ],
    [
        "bottom"
    ]
];
// Set webhook using Telegram API directly
async function setWebhook(url) {
    try {
        const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].post(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/setWebhook`, {
            url: `${url}/api/webhook`
        });
        console.log(response.data);
        const result = response.data;
        if (!result.ok) {
            throw new Error(`Failed to set webhook: ${result.description}`);
        }
        return result;
    } catch (error) {
        console.error("Error setting webhook:", error);
        throw error;
    }
}
// Initialize bot handlers
async function initializeBot() {
    try {
        console.log("Initializing bot");
        // Initialize database
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["initializeDatabase"])();
        // Set webhook for serverless deployment
        if (process.env.WEBHOOK_URL) {
            console.log("Setting webhook to", process.env.WEBHOOK_URL);
            await setWebhook(process.env.WEBHOOK_URL);
            console.log("Webhook set successfully");
        }
        console.log("Bot initialized successfully");
    } catch (error) {
        console.error("Error initializing bot:", error);
        throw error;
    }
}
// Handle /start command
async function handleStart(msg) {
    const userId = msg.from.id;
    const chatId = msg.chat.id;
    try {
        const hasUserWatermark = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasWatermark"])(userId.toString());
        if (hasUserWatermark) {
            const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUser"])(userId.toString());
            if (!user) {
                const message = `Welcome to the Watermark Bot! ðŸ–¼ï¸\n\nI'll help you add watermarks to your photos.\n\nTo get started, please send me an image that you'd like to use as your watermark (preferably a PNG with transparent background).`;
                await bot.sendMessage(chatId, message);
                return;
            }
            const message = `Welcome back! ðŸŽ‰\n\nYour watermark is set to position: *${user.watermark_position}*\n\nSend me a photo to add your watermark, or send a new image to update your watermark.`;
            await bot.sendMessage(chatId, message, {
                parse_mode: "Markdown"
            });
        } else {
            const message = `Welcome to the Watermark Bot! ðŸ–¼ï¸\n\nI'll help you add watermarks to your photos.\n\nTo get started, please send me an image that you'd like to use as your watermark (preferably a PNG with transparent background).`;
            userStates.set(userId, "waiting_for_watermark");
            await bot.sendMessage(chatId, message);
        }
    } catch (error) {
        console.error("Error handling start command:", error);
        await bot.sendMessage(chatId, "Sorry, something went wrong. Please try again.");
    }
}
// Handle photo messages
async function handlePhoto(msg) {
    const userId = msg.from.id;
    const chatId = msg.chat.id;
    const photo = msg.photo[msg.photo.length - 1]; // Get the largest photo
    const fileId = photo.file_id;
    try {
        const userState = userStates.get(userId);
        // If user is waiting to upload watermark
        if (userState === "waiting_for_watermark") {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUserWatermark"])(userId.toString(), fileId);
            userStates.delete(userId);
            const message = `Perfect! âœ… Your watermark has been set.\n\nNow send me any photo and I'll add your watermark to it!`;
            await bot.sendMessage(chatId, message);
            return;
        }
        // If user is changing watermark for a specific photo
        if (userState && userState.startsWith("changing_watermark_")) {
            const photoId = userState.split("_")[2];
            const photoFileId = photoFileIds.get(photoId);
            if (!photoFileId) {
                await bot.sendMessage(chatId, "Original photo not found. Please try processing a new photo.");
                userStates.delete(userId);
                return;
            }
            // Update user's watermark
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUserWatermark"])(userId.toString(), fileId);
            userStates.delete(userId);
            // Get user's updated data
            const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUser"])(userId.toString());
            if (!user) {
                await bot.sendMessage(chatId, "User data not found. Please try /start again.");
                return;
            }
            // Process the original photo with new watermark
            const watermarkedBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$imageProcessor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processImage"])(photoFileId, user.watermark_file_id, user.watermark_position, bot);
            // Create keyboard with both buttons
            const keyboard = {
                inline_keyboard: [
                    [
                        {
                            text: "ðŸŽ¨ Customize Position",
                            callback_data: `customize_${photoId}`
                        },
                        {
                            text: "ðŸ”„ Change Watermark",
                            callback_data: `change_watermark_${photoId}`
                        }
                    ]
                ]
            };
            // Send updated photo
            await bot.sendPhoto(chatId, watermarkedBuffer, {
                caption: `Updated! New watermark applied. Position: ${user.watermark_position}`,
                reply_markup: keyboard
            });
            await bot.sendMessage(chatId, "âœ… Watermark updated successfully!");
            return;
        }
        // Check if user has watermark
        const hasUserWatermark = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasWatermark"])(userId.toString());
        if (!hasUserWatermark) {
            const message = `You don't have a watermark set yet. Please send me an image to use as your watermark first.`;
            userStates.set(userId, "waiting_for_watermark");
            await bot.sendMessage(chatId, message);
            return;
        }
        // Process the photo with watermark
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUser"])(userId.toString());
        if (!user) {
            await bot.sendMessage(chatId, "User data not found. Please try /start again.");
            return;
        }
        const watermarkedBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$imageProcessor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processImage"])(fileId, user.watermark_file_id, user.watermark_position, bot);
        // Create a short identifier for the photo
        const photoId = `p${++photoCounter}`;
        photoFileIds.set(photoId, fileId);
        // Clean up old photo IDs to prevent memory leaks (keep only last 100)
        if (photoFileIds.size > 100) {
            const keysToDelete = Array.from(photoFileIds.keys()).slice(0, photoFileIds.size - 100);
            keysToDelete.forEach((key)=>photoFileIds.delete(key));
        }
        // Create inline keyboard for position customization
        const keyboard = {
            inline_keyboard: [
                [
                    {
                        text: "ðŸŽ¨ Customize Position",
                        callback_data: `customize_${photoId}`
                    },
                    {
                        text: "ðŸ”„ Change Watermark",
                        callback_data: `change_watermark_${photoId}`
                    }
                ]
            ]
        };
        // Send watermarked photo
        await bot.sendPhoto(chatId, watermarkedBuffer, {
            caption: `Here's your photo with watermark! Position: ${user.watermark_position}`,
            reply_markup: keyboard
        });
    } catch (error) {
        console.error("Error handling photo:", error);
        await bot.sendMessage(chatId, "Sorry, there was an error processing your photo. Please try again.");
    }
}
// Handle callback queries (inline buttons)
async function handleCallbackQuery(query) {
    const userId = query.from.id;
    const chatId = query.message.chat.id;
    const data = query.data;
    try {
        if (data.startsWith("customize_")) {
            const photoId = data.split("_")[1];
            const photoFileId = photoFileIds.get(photoId);
            if (!photoFileId) {
                await bot.answerCallbackQuery(query.id, {
                    text: "Photo not found. Please try again."
                });
                return;
            }
            // Store the photo file ID for later use
            userStates.set(userId, `customizing_${photoId}`);
            const keyboard = {
                inline_keyboard: POSITION_OPTIONS.map((row)=>row.map((position)=>({
                            text: position.replace("-", " ").toUpperCase(),
                            callback_data: `position_${position}_${photoId}`
                        })))
            };
            await bot.editMessageReplyMarkup(keyboard, {
                chat_id: chatId,
                message_id: query.message.message_id
            });
            try {
                await bot.answerCallbackQuery(query.id, {
                    text: "Choose watermark position:"
                });
            } catch (error) {
                console.log("Callback query already answered or timed out, continuing...");
            }
        } else if (data.startsWith("position_")) {
            const [, position, photoId] = data.split("_");
            const photoFileId = photoFileIds.get(photoId);
            if (!photoFileId) {
                try {
                    await bot.answerCallbackQuery(query.id, {
                        text: "Photo not found. Please try again."
                    });
                } catch (error) {
                    console.log("Callback query already answered or timed out, continuing...");
                }
                return;
            }
            // Update user's watermark position
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateWatermarkPosition"])(userId.toString(), position);
            // Get user's watermark
            const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUser"])(userId.toString());
            if (!user) {
                await bot.answerCallbackQuery(query.id, {
                    text: "User data not found. Please try /start again."
                });
                return;
            }
            // Process photo with new position
            const watermarkedBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$imageProcessor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processImage"])(photoFileId, user.watermark_file_id, position, bot);
            // Create new keyboard
            const keyboard = {
                inline_keyboard: [
                    [
                        {
                            text: "ðŸŽ¨ Customize Position",
                            callback_data: `customize_${photoId}`
                        },
                        {
                            text: "ðŸ”„ Change Watermark",
                            callback_data: `change_watermark_${photoId}`
                        }
                    ]
                ]
            };
            // Send updated photo
            await bot.sendPhoto(chatId, watermarkedBuffer, {
                caption: `Updated! Watermark position: ${position}`,
                reply_markup: keyboard
            });
            // Delete the original message
            await bot.deleteMessage(chatId, query.message.message_id);
            userStates.delete(userId);
            await bot.answerCallbackQuery(query.id, {
                text: "Position updated!"
            });
        } else if (data.startsWith("change_watermark_")) {
            const photoId = data.split("_")[2];
            const photoFileId = photoFileIds.get(photoId);
            if (!photoFileId) {
                await bot.answerCallbackQuery(query.id, {
                    text: "Photo not found. Please try again."
                });
                return;
            }
            // Store the photo file ID for later use and set state to wait for new watermark
            userStates.set(userId, `changing_watermark_${photoId}`);
            await bot.answerCallbackQuery(query.id, {
                text: "Please send me a new watermark image."
            });
            await bot.sendMessage(chatId, "Please send me a new image to use as your watermark (preferably a PNG with transparent background).");
        }
    } catch (error) {
        console.error("Error handling callback query:", error);
        await bot.answerCallbackQuery(query.id, {
            text: "Error occurred. Please try again."
        });
    }
}
// Handle text messages
async function handleText(msg) {
    const userId = msg.from.id;
    const chatId = msg.chat.id;
    const text = msg.text;
    if (text === "/start") {
        console.log("Starting bot");
        await handleStart(msg);
    } else {
        const userState = userStates.get(userId);
        if (userState === "waiting_for_watermark") {
            await bot.sendMessage(chatId, "Please send me an image file to use as your watermark.");
        } else if (userState && userState.startsWith("changing_watermark_")) {
            await bot.sendMessage(chatId, "Please send me an image file to use as your new watermark.");
        } else {
            await bot.sendMessage(chatId, "Send me a photo to add your watermark, or use /start to see your options.");
        }
    }
}
// Main message handler
async function handleMessage(msg) {
    try {
        if (msg.photo) {
            await handlePhoto(msg);
        } else if (msg.text) {
            await handleText(msg);
        }
    } catch (error) {
        console.error("Error handling message:", error);
        try {
            await bot.sendMessage(msg.chat.id, "Sorry, something went wrong. Please try again.");
        } catch (sendError) {
            console.error("Error sending error message:", sendError);
        }
    }
}
// Webhook handler for serverless deployment
async function handleWebhook(body) {
    try {
        if (body.message) {
            await handleMessage(body.message);
        } else if (body.callback_query) {
            await handleCallbackQuery(body.callback_query);
        }
        return {
            status: "OK"
        };
    } catch (error) {
        console.error("Webhook error:", error);
        throw error;
    }
}
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/app/api/init/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$bot$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/bot.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$bot$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$bot$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
async function GET() {
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$bot$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["initializeBot"])();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            status: "OK",
            message: "Bot initialized successfully",
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error("Initialization error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Failed to initialize bot",
            details: error instanceof Error ? error.message : "Unknown error"
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__e6d5df08._.js.map